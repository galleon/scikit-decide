(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{502:function(a,e,t){"use strict";t.r(e);var r=t(51),l=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"builders-solver-parallelability"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#builders-solver-parallelability"}},[a._v("#")]),a._v(" builders.solver.parallelability")]),a._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#parallelsolver"}},[a._v("ParallelSolver")])])])]),t("p"),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),t("skdecide-summary")],1),a._v(" "),t("h2",{attrs:{id:"parallelsolver"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parallelsolver"}},[a._v("#")]),a._v(" ParallelSolver")]),a._v(" "),t("p",[a._v("A solver must inherit this class if it wants to call several cloned parallel domains in separate concurrent processes.\nThe solver is meant to be called either within a 'with' context statement, or to be cleaned up using the close() method.")]),a._v(" "),t("h3",{attrs:{id:"constructor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[a._v("#")]),a._v(" Constructor "),t("Badge",{attrs:{text:"ParallelSolver",type:"tip"}})],1),a._v(" "),t("skdecide-signature",{attrs:{name:"ParallelSolver",sig:{params:[{name:"domain_factory",annotation:"Callable[[], Domain]"},{name:"parallel",default:"False",annotation:"bool"},{name:"shared_memory_proxy",default:"None"}]}}}),a._v(" "),t("p",[a._v("Creates a parallelizable solver")]),a._v(" "),t("h4",{attrs:{id:"parameters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[a._v("#")]),a._v(" Parameters")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("domain_factory")]),a._v(": A callable with no argument returning the domain to solve (factory is the domain class if None).")]),a._v(" "),t("li",[t("strong",[a._v("parallel")]),a._v(": True if the solver is run in parallel mode.")]),a._v(" "),t("li",[t("strong",[a._v("shared_memory_proxy")]),a._v(": Shared memory proxy to use if not None, otherwise run piped parallel domains.")])]),a._v(" "),t("h3",{attrs:{id:"call-domain-method"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#call-domain-method"}},[a._v("#")]),a._v(" call_domain_method "),t("Badge",{attrs:{text:"ParallelSolver",type:"tip"}})],1),a._v(" "),t("skdecide-signature",{attrs:{name:"call_domain_method",sig:{params:[{name:"self"},{name:"name"},{name:"args"}]}}}),a._v(" "),t("p",[a._v("Calls a parallel domain's method.\nThis is the only way to get a domain method for a parallel domain.")]),a._v(" "),t("h3",{attrs:{id:"close"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#close"}},[a._v("#")]),a._v(" close "),t("Badge",{attrs:{text:"ParallelSolver",type:"tip"}})],1),a._v(" "),t("skdecide-signature",{attrs:{name:"close",sig:{params:[{name:"self"}]}}}),a._v(" "),t("p",[a._v("Joins the parallel domains' processes.\nNot calling this method (or not using the 'with' context statement)\nresults in the solver forever waiting for the domain processes to exit.")]),a._v(" "),t("h3",{attrs:{id:"get-domain"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-domain"}},[a._v("#")]),a._v(" get_domain "),t("Badge",{attrs:{text:"ParallelSolver",type:"tip"}})],1),a._v(" "),t("skdecide-signature",{attrs:{name:"get_domain",sig:{params:[{name:"self"}]}}}),a._v(" "),t("p",[a._v("Returns the domain, optionally creating a parallel domain if not already created.")]),a._v(" "),t("h3",{attrs:{id:"initialize"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#initialize"}},[a._v("#")]),a._v(" _initialize "),t("Badge",{attrs:{text:"ParallelSolver",type:"tip"}})],1),a._v(" "),t("skdecide-signature",{attrs:{name:"_initialize",sig:{params:[{name:"self"}]}}}),a._v(" "),t("p",[a._v("Launches the parallel domains.\nThis method requires to have previously recorded the self._domain_factory (e.g. after calling _init_solve),\nthe set of lambda functions passed to the solver's constructor (e.g. heuristic lambda for heuristic-based solvers),\nand whether the parallel domain jobs should notify their status via the IPC protocol (required when interacting with\nother programming languages like C++)")])],1)}),[],!1,null,null,null);e.default=l.exports}}]);